import logging
from decimal import Decimal, ROUND_HALF_UP
from aiogram import Dispatcher, types, F
from sqlalchemy.ext.asyncio import AsyncSession

from app.config import settings
from app.database.models import User
from app.services.payment_service import PaymentService
from app.external.telegram_stars import TelegramStarsService
from app.database.crud.user import get_user_by_telegram_id
from app.localization.loader import DEFAULT_LANGUAGE
from app.localization.texts import get_texts

logger = logging.getLogger(__name__)


async def handle_pre_checkout_query(query: types.PreCheckoutQuery):
    texts = get_texts(DEFAULT_LANGUAGE)

    try:
        logger.info(f"üìã Pre-checkout query –æ—Ç {query.from_user.id}: {query.total_amount} XTR, payload: {query.invoice_payload}")

        allowed_prefixes = ("balance_", "admin_stars_test_")

        if not query.invoice_payload or not query.invoice_payload.startswith(allowed_prefixes):
            logger.warning(f"–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π payload: {query.invoice_payload}")
            await query.answer(
                ok=False,
                error_message=texts.t(
                    "STARS_PRECHECK_INVALID_PAYLOAD",
                    "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                ),
            )
            return

        try:
            from app.database.database import get_db
            async for db in get_db():
                user = await get_user_by_telegram_id(db, query.from_user.id)
                if not user:
                    logger.warning(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {query.from_user.id} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ë–î")
                    await query.answer(
                        ok=False,
                        error_message=texts.t(
                            "STARS_PRECHECK_USER_NOT_FOUND",
                            "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.",
                        ),
                    )
                    return
                texts = get_texts(user.language or DEFAULT_LANGUAGE)
                break
        except Exception as db_error:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î –≤ pre_checkout_query: {db_error}")
            await query.answer(
                ok=False,
                error_message=texts.t(
                    "STARS_PRECHECK_TECHNICAL_ERROR",
                    "–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                ),
            )
            return

        await query.answer(ok=True)
        logger.info(f"‚úÖ Pre-checkout –æ–¥–æ–±—Ä–µ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {query.from_user.id}")

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ pre_checkout_query: {e}", exc_info=True)
        await query.answer(
            ok=False,
            error_message=texts.t(
                "STARS_PRECHECK_TECHNICAL_ERROR",
                "–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
            ),
        )


async def handle_successful_payment(
    message: types.Message,
    db: AsyncSession,
    **kwargs
):
    texts = get_texts(DEFAULT_LANGUAGE)

    try:
        payment = message.successful_payment
        user_id = message.from_user.id

        logger.info(
            f"üí≥ –£—Å–ø–µ—à–Ω—ã–π Stars –ø–ª–∞—Ç–µ–∂ –æ—Ç {user_id}: "
            f"{payment.total_amount} XTR, "
            f"payload: {payment.invoice_payload}, "
            f"charge_id: {payment.telegram_payment_charge_id}"
        )

        user = await get_user_by_telegram_id(db, user_id)
        texts = get_texts(user.language if user and user.language else DEFAULT_LANGUAGE)

        if not user:
            logger.error(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –Ω–µ –Ω–∞–π–¥–µ–Ω –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ Stars –ø–ª–∞—Ç–µ–∂–∞")
            await message.answer(
                texts.t(
                    "STARS_PAYMENT_USER_NOT_FOUND",
                    "‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.",
                )
            )
            return

        payment_service = PaymentService(message.bot)
        success = await payment_service.process_stars_payment(
            db=db,
            user_id=user.id,
            stars_amount=payment.total_amount,
            payload=payment.invoice_payload,
            telegram_payment_charge_id=payment.telegram_payment_charge_id
        )
        
        if success:
            rubles_amount = TelegramStarsService.calculate_rubles_from_stars(payment.total_amount)
            amount_kopeks = int((rubles_amount * Decimal(100)).to_integral_value(rounding=ROUND_HALF_UP))
            amount_text = settings.format_price(amount_kopeks).replace(" ‚ÇΩ", "")

            keyboard = await payment_service.build_topup_success_keyboard(user)

            transaction_id_short = payment.telegram_payment_charge_id[:8]

            await message.answer(
                texts.t(
                    "STARS_PAYMENT_SUCCESS",
                    "üéâ <b>–ü–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω!</b>\n\n"
                    "‚≠ê –ü–æ—Ç—Ä–∞—á–µ–Ω–æ –∑–≤–µ–∑–¥: {stars_spent}\n"
                    "üí∞ –ó–∞—á–∏—Å–ª–µ–Ω–æ –Ω–∞ –±–∞–ª–∞–Ω—Å: {amount} ‚ÇΩ\n"
                    "üÜî ID —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: {transaction_id}...\n\n"
                    "–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ! üöÄ",
                ).format(
                    stars_spent=payment.total_amount,
                    amount=amount_text,
                    transaction_id=transaction_id_short,
                ),
                parse_mode="HTML",
                reply_markup=keyboard,
            )

            logger.info(
                "‚úÖ Stars –ø–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å %s, %s –∑–≤–µ–∑–¥ ‚Üí %s",
                user.id,
                payment.total_amount,
                settings.format_price(amount_kopeks),
            )
        else:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ Stars –ø–ª–∞—Ç–µ–∂–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.id}")
            await message.answer(
                texts.t(
                    "STARS_PAYMENT_ENROLLMENT_ERROR",
                    "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞—á–∏—Å–ª–µ–Ω–∏–∏ —Å—Ä–µ–¥—Å—Ç–≤. "
                    "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É, –ø–ª–∞—Ç–µ–∂ –±—É–¥–µ—Ç –ø—Ä–æ–≤–µ—Ä–µ–Ω –≤—Ä—É—á–Ω—É—é.",
                )
            )

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ successful_payment: {e}", exc_info=True)
        await message.answer(
            texts.t(
                "STARS_PAYMENT_PROCESSING_ERROR",
                "‚ùå –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–ª–∞—Ç–µ–∂–∞. "
                "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º—ã.",
            )
        )


def register_stars_handlers(dp: Dispatcher):
    
    dp.pre_checkout_query.register(
        handle_pre_checkout_query,
        F.currency == "XTR" 
    )
    
    dp.message.register(
        handle_successful_payment,
        F.successful_payment
    )
    
    logger.info("üåü –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ Telegram Stars –ø–ª–∞—Ç–µ–∂–µ–π")
